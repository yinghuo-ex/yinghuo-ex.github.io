[{"title":"哈夫曼树","date":"2021-12-08T16:00:00.000Z","url":"/2021/12/09/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/","categories":[["数据结构","/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"content":" 解决问题哈夫曼树解决了无损压缩问题 解决方法对于一个字符串 AAABBC 正常储存需要六位char，也就是6个字节，一个字节8位，也就是需要48位，这个时候就可以考虑到打表的时候苦于内存不够之类的悲伤情况，当然日用也有需要。 如果，我们能把一个需要XXXX XXXX来储存同时大量储存信息没用的存储方式用类似哈希映射的方案，很显然能够极大提高储存效率。 这时就是哈夫曼树的出场环境了 过程类似合并果子，共有两步 预处理把所有字符出现次数储存，也就是3 2 1 1.找到最小的两个，并合并 2.将这两个的和再次放入 直到剩下唯一一个 此时我们可以对几个数字进行编码 我们可以进行一下比较 对于AAABBC 原串为XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX 更改为0 0 0 11 11 10 48 9 好耶！ sp 这里引入一个概念 WPL:WPL 是 Weight external Path Length 加权路径长度 这个概念来自于二叉树,对于一个编码,WPL越低,效率越高 性质1.所有字符节点都为叶子节点 不存在一个字符的表示，是另一个字符的前缀 证明： 使用反证法,若存在一个字符是另一个字符的前缀: 存在一个字符是另一个字符的前缀 一个字符是另一个字符的直系祖先 字符必为叶子节点 非法 2.构型不为一,但WPL一定最低: 简单考虑这个就很不错,直接子树交换 "},{"title":"KMP","date":"2021-12-08T16:00:00.000Z","url":"/2021/12/09/KMP/","categories":[["数据结构","/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"content":" 解决问题KMP算法解决了模式串O（n + m）匹配问题，其中next数组解决了字符串最长相同前后缀问题 解决方法首先朴素的考虑暴力匹配 AAAAAF AF 复杂度为O(n * m)，显然没法实现日用 因此需要一个高效匹配方案 考虑一下我们的过程 定义文本串为第i位，模式串为第j位 当 j 与 i 失配时，在 i+1 位上需要把 j 回归到第一位 很显然在遍历过程不可少的情况下，可以优化的部分在于回归这个过程上 所以开始正经推理回归过程：若模式串能匹配到第 j 位，说明前 j - 1位完全匹配， 那么若第 j 位失配， 能利用的就是完全匹配这一条件 换而言之，如果不想要直接回归到1， 应当确保，回归后，前k位可以直接在文本串上直接匹配 换而言之， 前k位和后k位完全相同 实在是非常高妙 换而言之，我们只需要得到模式串的next， 每次失配就回到它对应的K，如果到头了就说明没救了，下一位继续吧 程序实现 性质"},{"title":"B.Stoned-Game","date":"2021-12-05T16:00:00.000Z","url":"/2021/12/06/B.Stoned-Game/","tags":[["贪心","/tags/%E8%B4%AA%E5%BF%83/"],["博弈","/tags/%E5%8D%9A%E5%BC%88/"]],"categories":[["题解","/categories/%E9%A2%98%E8%A7%A3/"]],"content":"呜呜不能咸鱼了，努力刷构造尽快提高蒙猜水平 B. Stoned Game链接 给定n堆石子，每次轮流取一个，其中，上个人取过的堆当前操作者不能取，求谁能赢 解析1.若只存在1堆，alice胜 bob不能选alice选过的 2.若只存在两堆，若两堆相同高度，bob胜，反之alice胜 （这里插入一下，常常出现的一个情况是，博弈需要从特殊到普遍，从简单到复杂进行整体感受） 3.若存在多堆，在进入一堆状态前，一定会进入两堆状态，也就是进入两堆的状态决定胜负sp 最高的一枝如果高于其他所有 alice直接获胜（无敌的青眼白龙） 在两人有来有回的操作下，奇偶性一定不变，若为奇数，则一定不会出现两队相同高度，alice胜 反之，若为偶数，在有来有回的情况下，bob一定能实现两个相同高度的构造，bob胜"},{"title":"D.Carousel","date":"2021-12-05T16:00:00.000Z","url":"/2021/12/06/D.Carousel/","tags":[["贪心","/tags/%E8%B4%AA%E5%BF%83/"],["构造","/tags/%E6%9E%84%E9%80%A0/"]],"categories":[["题解","/categories/%E9%A2%98%E8%A7%A3/"]],"content":" D.Carousel链接]() 给定n个数，围成一圈，对每个数进行涂色，其中对于相邻两数，若数值不同，颜色不同，求最少用多少种颜色可以涂完 解析1.对于全部相同 全1 2.对于偶数 存在构造 1 2 1 2 1 2使得对于任何情况都合法 3.这个时候考虑，奇数情况能不能变成偶数情况，使得尽可能少呢，当然是可以的，由于存在数字可以用相同入颜色，只需要让两个相邻数同时用1比如 1 2 1 1 2 就可以看做是 1 2 1 2的变体一定合法，反之一定不合法。"},{"title":"math","date":"2021-11-28T16:00:00.000Z","url":"/2021/11/29/math/","categories":[["undefined",""]],"content":" 1^{2 \\le 8_i}1^{2 \\le 8_i}1^{2 \\le 8_i}1^{2 \\le 8_i}"},{"title":"D. Min-Cost-String","date":"2021-11-16T16:00:00.000Z","url":"/2021/11/17/D.%20Min-Cost-String/","tags":[["字符串","/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"],["哈希","/tags/%E5%93%88%E5%B8%8C/"],["贪心","/tags/%E8%B4%AA%E5%BF%83/"]],"categories":[["题解","/categories/%E9%A2%98%E8%A7%A3/"]],"content":"构造一个字符串，给定n, k。n代表字符串长度，k代表字符串可以使用的符号范围（自a起），对于同时 这样的片段会使得字符串的消耗加一，求最小消耗. 对于字符串的处理优先考虑哈希​(本人就憨憨的直接开写),把这道题将进一步考虑，对于组合ab，当它被用过后，它的选择优先度会降低，因为此前与他匹配过的每一对都可以继续匹配，因此，贪心的方向是尽可能的平均使用各组合，于是我们可以记录一下已经使用过的组合 对于使用次数不相同的组合，应使用使用次数少的 对于使用次数相同的组合，应使用字典序靠后的（这里，因为我们的遍历是从a-&gt;z,那么我们如果不以这个为判断，会浪费掉本可以使用的部分） 于是代码如下 "},{"title":"任务清单","date":"2021-11-16T16:00:00.000Z","url":"/2021/11/17/%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95/","categories":[["学习资料","/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"]],"content":"山就在那里 数学场 C D一个晚自习"},{"title":"正经学习资料","date":"2021-11-16T16:00:00.000Z","url":"/2021/11/17/%E6%AD%A3%E7%BB%8F%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/","categories":[["学习资料","/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"]],"content":"MARKDOWN篇现在时间是2021.11.29，ZSY同学在多日前表示：MARKDOWN用不了，在鸽了几天后花了一个晚自习成功修好 hexo内置的MARKDOWN只支持简单操作，对于注入这样的复杂语句无法渲染，在这个链接完成修改"},{"title":"模板","date":"2021-11-16T16:00:00.000Z","url":"/2021/11/17/%E8%8D%A7%E6%83%91%E7%9A%84%E6%A8%A1%E6%9D%BF/","categories":[["学习资料","/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"]],"content":"前言俗话说得好，记住是不可能的，当手残选手不得不挑起代码手的大梁，一份自产自用的模板无疑是绕开漫漫debug之路的明灯。 在记了在记了 奇奇怪怪小妙招 快读 逆元 位运算 归并排序求逆序对 KMP 字典树 最短路堆优化 dijkstra特别注意，dj不能处理负边问题 最小生成树kruskal LCA dfs序前闭后开，dfs序可以将树以区间的形式储存，从而使用线段树等高级结构进行处理 单调队列​ O(n) 处理 给定长度区间最值 树状数组空间复杂度O(n) ！！！ 仅支持单点修改 以1为起点 常数优于线段树 ST表离线O(nlogn)预处理， O（1）询问 线段树常规 加法乘法线段树 区间第k大 主席树 内带离散化模板 最长公共子序列 线性筛 哈希往往在以图为基本单元进行操作的场景下 可以用哈希将图储存为数 使得操作复杂度降低 对于哈希 可以理解为把每一位上的字符看作一个p进制的对应位上的权 那么对于一个字符串ABCD 可以理解为 $A P^3 + B P^2 + C P^1 + D P^0$ 对于字符A 可以理解为 当我们获取BCD时应将BCD加入过程中A所的的加上 可知 x = 串长串长 进阶一下 对于ABCDEF 想要拆出ABF也就是间隔CDE求取 通过ask我们可以获取 AB = $A P^1 + B P^0F * P^0$ 只需要把靠左部分乘以靠右部分长度对应的权 即 右串长 玄不救非，一组素数不行换换试试吧 高精度 "}]