[{"title":"math","date":"2021-11-28T16:00:00.000Z","url":"/2021/11/29/math/","categories":[["undefined",""]],"content":"1^{2 \\le 8_i}1^{2 \\le 8_i}1^{2 \\le 8_i}1^{2 \\le 8_i}1^{2 \\le 8_i}1^{2 \\le 8_i}"},{"title":"D. Min Cost String","date":"2021-11-16T16:00:00.000Z","url":"/2021/11/17/D.%20Min%20Cost%20String/","tags":[["字符串","/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"],["哈希","/tags/%E5%93%88%E5%B8%8C/"],["贪心","/tags/%E8%B4%AA%E5%BF%83/"]],"categories":[["题解","/categories/%E9%A2%98%E8%A7%A3/"]],"content":"构造一个字符串，给定n, k。n代表字符串长度，k代表字符串可以使用的符号范围（自a起），对于$s_i == s_j 同时 s_{i + 1} == s_{j + 1}$ 这样的片段会使得字符串的消耗加一，求最小消耗. 对于字符串的处理优先考虑哈希​(本人就憨憨的直接开写),把这道题将进一步考虑，对于组合ab，当它被用过后，它的选择优先度会降低，因为此前与他匹配过的每一对都可以继续匹配，因此，贪心的方向是尽可能的平均使用各组合，于是我们可以记录一下已经使用过的组合 对于使用次数不相同的组合，应使用使用次数少的 对于使用次数相同的组合，应使用字典序靠后的（这里，因为我们的遍历是从a-&gt;z,那么我们如果不以这个为判断，会浪费掉本可以使用的部分） 于是代码如下 "},{"title":"任务清单","date":"2021-11-16T16:00:00.000Z","url":"/2021/11/17/%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95/","categories":[["学习资料","/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"]],"content":"山就在那里 数学场 C D一个晚自习"},{"title":"模板","date":"2021-11-16T16:00:00.000Z","url":"/2021/11/17/%E8%8D%A7%E6%83%91%E7%9A%84%E6%A8%A1%E6%9D%BF/","categories":[["学习资料","/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"]],"content":"前言俗话说得好，记住是不可能的，当手残选手不得不挑起代码手的大梁，一份自产自用的模板无疑是绕开漫漫debug之路的明灯。 在记了在记了 奇奇怪怪小妙招 快读 逆元 位运算 归并排序求逆序对 字典树 最短路堆优化 dijkstra特别注意，dj不能处理负边问题 最小生成树kruskal LCA dfs序前闭后开，dfs序可以将树以区间的形式储存，从而使用线段树等高级结构进行处理 单调队列​ O(n) 处理 给定长度区间最值 树状数组空间复杂度O(n) ！！！ 仅支持单点修改 以1为起点 常数优于线段树 ST表离线O(nlogn)预处理， O（1）询问 线段树常规 加法乘法线段树 区间第k大 主席树 内带离散化模板 最长公共子序列 线性筛 哈希往往在以图为基本单元进行操作的场景下 可以用哈希将图储存为数 使得操作复杂度降低 对于哈希 可以理解为把每一位上的字符看作一个p进制的对应位上的权 那么对于一个字符串ABCD 可以理解为 $A P^3 + B P^2 + C P^1 + D P^0$ 对于字符A 可以理解为 $A * P^0$ 当我们获取BCD时应将BCD加入过程中A所的的$P^x$加上 可知 x = $P^(串A长 - 串B长)$ 进阶一下 对于ABCDEF 想要拆出ABF也就是间隔CDE求取 通过ask我们可以获取 AB = $A P^1 + B P^0$ F = $F * P^0$ 只需要把靠左部分乘以靠右部分长度对应的权 即 $p^(右串长)$ 玄不救非，一组素数不行换换试试吧 高精度 "}]